JavaScript Refresher:
    +variable types:
        +var: old variable type only exists still for backwards compatibility
        +const: constant values
        +let: new var variable type, variable values
    +arrow functions:
        +regular function: function funcName(){}
        +arrow function: const funcName = () => {}
        +syntax shortcuts:
            +one argument only:
                +can remove () from arguments
                +const funcName = arg => {}
            +one line function body:
                +can remove {} and return keyword
                + codeLine will be returned
                +const funcName = () => codeLine
        +benefits of arrow function:
            +slightly smaller syntax
            +fixes issues with 'this' value, 'this' value is the expected scope.
    +Modules: import js file into another js file
        +Imports: add js to current js file.
            +import name from jsFile: imports default of jsFile into name.
            +import {value} from jsFile: imports specific value of jsFile into the same name as defined in js file.
                +line above makes use of destructuring
                +alternative: import {value as name} from jsFile
            +import * as name from jsFile: imports everything under name alias.
                +name.exportName
        +Exports: allow part of js file to be imported to another file.
            +default export: export default name
            +value export: export type name
    +Classes: blueprints for objects.
        +syntax:
            class Person{
                constructor(){
                    //This is run by default whenever class is instantiated
                }
                name = 'value',
                call = () => {...}
            }
        +use:
            +const myPerson = new Person();
            person.call();
        +inheritance:
            +class Person extends Master
            +to make use of parent class constructor, super() needs to be run in the child constructor.
        +Properties: variables attached to classes/objects
        +Methods: functions attached to classes/objects
    +Spread & Rest Operators: ...
        Spread: splits up array elements or object Properties
            +const newArray = [...oldArray, 1, 2];
        Rest: merge a list of function arguments into an array
            + function sortArgs(...args){
                return args;
            }
    +Destructuring: extracts array elements or object properties and stores them in variables
        +Arrays:
            +[a, b] = ['Hello', 'Max']
            +console.log(a) //Hello
            +console.log(b) //Max
        +Objects:
            +{name} = {name: 'Max', age: 28}
            +console.log(name); // Max
            +console.log(age); // undefined
    +Standard JS:
        +Reference Types: objects and arrays.
            +Stores pointers to values.
            +spread operator can be used to make proper copy, rather than reference.
        +Primitive Types: numbers, strings, booleans.
            +Makes copy of value.
        +Array functions:
            +array.arrayFunction(func): runs function on every element of array, functionality changes with arrayFunction type.

ReactJs:
    + a frontend js framework
    + generally used for "single-page-applications"
    + base react is focused on UI components extra functionality 
        is added through third party packages
    +Other frameworks: Angular(more features built in by default), Vue(more features than react less than angular)
    +React is all about components
        +separates page into groups of elements
        +all components are just js functions
    +Declarative Approach:
        +Define end state and let react figure out the actual js DOM instructions
    
    +JSX: JavaScript XML
        +HTML inside a js file, only works due to steps react takes before serving the webpage files.
        +Can be stored/used outside the return function.
    +Rules:
        +Application has to start with index.js
        +Application also needs an index.html(inside the public folder)
        +Naming Conventions:
            +components start capitalized and are then camelCase.
        +components can only have one root html element.
        +classes in JSX are set using className instead of class
    +"Props": custom HTML properties, arguments passed into components, generally named props. They are defined like html attributes. 
        +Props.children: each react component has this by default and it returns the elements in between the components tags.
            +Example:
                function Card(props) {
                    const classes = "card " + props.className;
                    return <div className={classes}>{props.children}</div>;
                }
    +Child to Parent data transfer:
        +This is done by passing a function from the parent to the child through props, the child then calls that function to pass the data back.
        +naming convention is to start the function name with onFunctionName.
    +Composition: building a page with smaller building blocks
    +User Interaction & State:
        +Events: node uses onEventName attributes of html to add event listeners
        +State: All node functions are run at the start of the app one time, in order to update values state needs to be used. This
            is done using the useState hook created by react. Each useState is an instance of the component.
            +Example:
                import { useState } from "react";
                const [title, setTitle] = useState(props.title);
            +useState: function that takes a value and returns an array with two values, the object being update and a function to update the value.
                +when useState is update the JSX is rerun, react keeps track of when useState is run and updates value accordingly.
           
            +Two Way Binding: listen to value changes and able to add state value back into value. 
                +Controlled component: component values are set in parent components.
                +Stateful/Smart: components that manage states, they have states in them.
                +Stateless/Dumb: components without states.
            +Lifting State Up: giving state from one component to the next, this is done by passing the state to the closest parent related to both components.
        +Rendering Lists:
            +Whenever you update a state and are dependent on the previous state an intermittent ()=> function should be used. This is because react schedules state changes
            which means there is a chance an outdated state could be used, the step mentioned before prevents this.
                +react by default provides the previous state of the element as the first argument of that function.
            +By default react only knows the the length of an array when adding a new element it is added to the bottom of the array and all values are updated to the correct postion.
                +To prevent this you use the key attribute on each item to tell react which element is associated with which key.
                    +key needs to be a unique numerical identifier within the list.
            +Dynamic Styling:
                +react overrides the style attribute and expects a js object with key value pairs where the key is the css attribute.
                    +Example:<div style={{ height: "50%" }}></div>
                    +if the css attribute has a - you need to use camelCase or put '' around the value.
                    +js variables can be used as the value but still need to compile with css syntax.
        +Hooks: react created methods that are called inside component functions, can't be nested.

